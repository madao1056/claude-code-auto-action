#!/bin/bash

# Claude Code Auto Architect - Hierarchical Agent Orchestration System
# This script automatically creates complete systems from high-level requirements

set -e

# Color codes
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
RED='\033[0;31m'
CYAN='\033[0;36m'
MAGENTA='\033[0;35m'
NC='\033[0m'

# Configuration paths
CLAUDE_HOME="$HOME/.claude"
ORCHESTRATION_CONFIG="$CLAUDE_HOME/agent-orchestration.json"
DEEP_THINKING_PROMPTS="$CLAUDE_HOME/prompts/deep-thinking.md"
PROJECT_DIR="$(pwd)"
LOGS_DIR="$PROJECT_DIR/.claude/logs"
WORKSPACE_DIR="$PROJECT_DIR/.claude/workspace"
SETTINGS_FILE="$CLAUDE_HOME/settings.json"
PERMISSIONS_FILE="$CLAUDE_HOME/permissions.json"

# Usage function
usage() {
    echo -e "${BLUE}Claude Code Auto Architect${NC}"
    echo ""
    echo "Usage: $0 <command> [options]"
    echo ""
    echo "Commands:"
    echo "  create    - Create a new system from requirements"
    echo "  analyze   - Analyze existing project and suggest improvements"
    echo "  upgrade   - Upgrade existing system with new features"
    echo ""
    echo "Options:"
    echo "  --requirement, -r    System requirement description"
    echo "  --type, -t          Project type (web, api, cli, mobile, desktop)"
    echo "  --stack, -s         Tech stack (auto-detect if not specified)"
    echo "  --parallel, -p      Max parallel agents (default: 10)"
    echo "  --verbose, -v       Verbose output"
    echo ""
    echo "Examples:"
    echo "  $0 create -r \"E-commerce platform with real-time inventory\""
    echo "  $0 create -r \"Task management API\" -t api -s node,typescript,postgres"
    echo "  $0 analyze"
    exit 1
}

# Initialize workspace
init_workspace() {
    echo -e "${YELLOW}Initializing workspace...${NC}"
    
    # Create necessary directories
    mkdir -p "$LOGS_DIR"
    mkdir -p "$WORKSPACE_DIR"/{architect,managers,workers,outputs}
    mkdir -p "$PROJECT_DIR"/.claude/{settings,prompts,templates}
    
    # Copy orchestration config if not exists
    if [ ! -f "$PROJECT_DIR/.claude/orchestration.json" ]; then
        cp "$ORCHESTRATION_CONFIG" "$PROJECT_DIR/.claude/orchestration.json"
    fi
    
    # Copy deep thinking prompts
    if [ ! -f "$PROJECT_DIR/.claude/prompts/deep-thinking.md" ]; then
        cp "$DEEP_THINKING_PROMPTS" "$PROJECT_DIR/.claude/prompts/deep-thinking.md"
    fi
    
    # Create project-specific CLAUDE.md if not exists
    if [ ! -f "$PROJECT_DIR/CLAUDE.md" ]; then
        cat > "$PROJECT_DIR/CLAUDE.md" << 'EOF'
# PROJECT INFORMATION

## Project Name
[Auto-generated by Claude Architect]

## Project Type
[To be determined]

## Technical Stack
[To be determined]

## Architecture
[To be determined]

# DEVELOPMENT GUIDELINES

## Automated System Design
This project uses Claude Code's hierarchical agent orchestration system for automated development.

### Agent Hierarchy
1. **Architect Agent**: System design and task decomposition
2. **Manager Agents**: Domain-specific planning and coordination
3. **Worker Agents**: Implementation and execution

### Deep Thinking Enabled
All agents use step-by-step reasoning, consider edge cases, and evaluate trade-offs.

# AGENT INSTRUCTIONS

## For Architect Agent
- Analyze requirements comprehensively
- Design scalable, maintainable architecture
- Create detailed task breakdowns
- Consider security and performance from the start

## For Manager Agents
- Coordinate worker agents efficiently
- Ensure quality and consistency
- Monitor progress and dependencies
- Report issues to architect

## For Worker Agents
- Follow best practices for the domain
- Write clean, tested code
- Document thoroughly
- Optimize for performance

# AUTOMATION SETTINGS

- Parallel execution: Enabled
- Auto-testing: Enabled
- Auto-documentation: Enabled
- Security scanning: Enabled
- Performance monitoring: Enabled
EOF
    fi
    
    echo -e "${GREEN}Workspace initialized${NC}"
}

# Pre-phase: Environment Setup
setup_environment() {
    local requirement="$1"
    
    echo -e "\n${CYAN}=== PRE-PHASE: ENVIRONMENT SETUP ===${NC}"
    echo -e "${YELLOW}Checking and installing required tools...${NC}"
    
    # Detect project type from requirement
    cat > "$WORKSPACE_DIR/architect/detect_requirements.md" << EOF
Analyze this requirement and determine what tools/dependencies need to be installed:
"$requirement"

Check if these tools are installed and install if missing:
1. Programming language runtimes (node, python, ruby, go, etc.)
2. Package managers (npm, pip, gem, cargo, etc.)
3. Database systems (postgres, mysql, mongodb, redis, etc.)
4. Build tools (make, cmake, gradle, etc.)
5. Container tools (docker, docker-compose)
6. Testing frameworks
7. Linting tools

For each missing tool:
- Check if it exists with 'which' or 'command -v'
- Install using appropriate package manager (brew, apt-get, etc.)
- Verify installation

Output a list of installed tools and any that couldn't be installed.
EOF

    cd "$WORKSPACE_DIR/architect"
    
    claude --dangerously-skip-permissions \
        "Read detect_requirements.md and set up the development environment. 
         Install any missing tools needed for the project.
         Use brew on macOS, apt-get on Ubuntu, etc.
         Create a setup_report.md with what was installed." \
        2>&1 | tee "$LOGS_DIR/environment_setup.log"
    
    echo -e "${GREEN}Environment setup complete${NC}"
}

# Phase 1: Architect Analysis
run_architect_analysis() {
    local requirement="$1"
    local project_type="$2"
    local tech_stack="$3"
    
    echo -e "\n${CYAN}=== PHASE 1: ARCHITECT ANALYSIS ===${NC}"
    echo -e "${BLUE}Requirement:${NC} $requirement"
    
    # Create analysis prompt
    cat > "$WORKSPACE_DIR/architect/analysis_prompt.md" << EOF
You are the System Architect in a hierarchical agent system. Analyze this requirement using step-by-step reasoning:

**Requirement**: $requirement
**Project Type**: ${project_type:-auto-detect}
**Suggested Stack**: ${tech_stack:-auto-detect}

Perform the following analysis:

1. **Requirement Analysis**
   - Break down functional requirements
   - Identify non-functional requirements
   - List constraints and assumptions
   - Consider edge cases

2. **Architecture Design**
   - Propose system architecture (microservices, monolith, serverless, etc.)
   - Design component structure
   - Plan data flow and storage
   - Consider scalability and security

3. **Technology Selection**
   - Choose appropriate tech stack with reasoning
   - Select frameworks and libraries
   - Plan development tools and CI/CD

4. **Task Decomposition**
   - Create hierarchical task breakdown
   - Identify dependencies
   - Estimate complexity
   - Assign to appropriate manager agents

5. **Resource Planning**
   - List all required services (databases, caches, queues, etc.)
   - Plan deployment strategy
   - Identify third-party integrations
   - Security requirements

6. **Development Environment**
   - Create docker-compose.yml for local development
   - Set up environment variables template
   - Configure development tools

Output format:
1. Save requirement analysis to: requirements_analysis.md
2. Save architecture design to: system_architecture.md
3. Save task breakdown to: task_breakdown.json
4. Save resource plan to: resources.md
5. Create initial docker-compose.yml
6. Create .env.example with all required variables

Use the deep thinking prompts from .claude/prompts/deep-thinking.md
Consider all extended capabilities from settings.json
EOF

    # Execute architect agent
    echo -e "${YELLOW}Architect analyzing requirements...${NC}"
    cd "$WORKSPACE_DIR/architect"
    
    # Use Claude with parallel sub-agents for different aspects
    claude --dangerously-skip-permissions \
        "Read the analysis prompt from analysis_prompt.md and perform comprehensive system analysis. 
         Use 3 parallel sub-agents:
         1. Requirements analyst - Focus on breaking down and clarifying requirements
         2. Architecture designer - Focus on system design and component structure
         3. Task planner - Focus on creating detailed task breakdown
         
         Each sub-agent should use step-by-step reasoning and deep thinking.
         Save outputs to the specified files." \
        2>&1 | tee "$LOGS_DIR/architect_analysis.log"
    
    # Verify outputs
    if [ -f "requirements_analysis.md" ] && [ -f "system_architecture.md" ] && [ -f "task_breakdown.json" ]; then
        echo -e "${GREEN}✓ Architect analysis complete${NC}"
        
        # Display summary
        echo -e "\n${BLUE}Architecture Summary:${NC}"
        head -20 system_architecture.md | grep -E "^##|^-" || true
    else
        echo -e "${RED}✗ Architect analysis failed${NC}"
        return 1
    fi
}

# Phase 2: Manager Planning
run_manager_planning() {
    echo -e "\n${CYAN}=== PHASE 2: MANAGER PLANNING ===${NC}"
    
    # Read task breakdown
    local task_breakdown="$WORKSPACE_DIR/architect/task_breakdown.json"
    if [ ! -f "$task_breakdown" ]; then
        echo -e "${RED}Error: Task breakdown not found${NC}"
        return 1
    fi
    
    # Create manager workspaces
    local managers=("frontend" "backend" "database" "devops" "testing")
    
    echo -e "${YELLOW}Launching parallel manager agents...${NC}"
    
    # Generate prompts for each manager
    for manager in "${managers[@]}"; do
        mkdir -p "$WORKSPACE_DIR/managers/$manager"
        
        cat > "$WORKSPACE_DIR/managers/$manager/planning_prompt.md" << EOF
You are the $manager Manager in a hierarchical agent system.

Based on the system architecture and task breakdown, create a detailed implementation plan.

**Context Files**:
- System Architecture: $WORKSPACE_DIR/architect/system_architecture.md
- Task Breakdown: $WORKSPACE_DIR/architect/task_breakdown.json

**Your Responsibilities**:
$(jq -r ".orchestration.hierarchy.managers.$manager.description" "$PROJECT_DIR/.claude/orchestration.json")

**Planning Requirements**:
1. Review assigned tasks from task breakdown
2. Create detailed implementation plan
3. Define sub-tasks for worker agents
4. Specify dependencies and timeline
5. List required resources and tools

**Deep Thinking Instructions**:
$(jq -r ".orchestration.hierarchy.managers.$manager.prompts.planning" "$PROJECT_DIR/.claude/orchestration.json")

Output: Save your plan to ${manager}_plan.md with:
- Overview
- Task list with priorities
- Dependencies
- Resource requirements
- Success criteria
EOF
    done
    
    # Execute all managers in parallel
    cd "$WORKSPACE_DIR/managers"
    
    claude --dangerously-skip-permissions \
        "You are coordinating 5 manager agents in parallel. Each manager has their planning prompt in their respective directories.
         
         Launch 5 parallel sub-agents:
         1. Frontend Manager - Read frontend/planning_prompt.md
         2. Backend Manager - Read backend/planning_prompt.md  
         3. Database Manager - Read database/planning_prompt.md
         4. DevOps Manager - Read devops/planning_prompt.md
         5. Testing Manager - Read testing/planning_prompt.md
         
         Each manager should:
         - Read the architect's outputs for context
         - Create their domain-specific implementation plan
         - Use step-by-step reasoning
         - Consider dependencies between domains
         - Save their plan to their directory
         
         Coordinate to ensure plans are aligned and dependencies are clear." \
        2>&1 | tee "$LOGS_DIR/manager_planning.log"
    
    # Verify all plans are created
    local all_plans_ready=true
    for manager in "${managers[@]}"; do
        if [ -f "$WORKSPACE_DIR/managers/$manager/${manager}_plan.md" ]; then
            echo -e "${GREEN}✓ ${manager^} Manager plan ready${NC}"
        else
            echo -e "${RED}✗ ${manager^} Manager plan missing${NC}"
            all_plans_ready=false
        fi
    done
    
    if [ "$all_plans_ready" = true ]; then
        echo -e "${GREEN}All manager plans complete${NC}"
    else
        echo -e "${RED}Some manager plans failed${NC}"
        return 1
    fi
}

# Phase 3: Worker Implementation
run_worker_implementation() {
    echo -e "\n${CYAN}=== PHASE 3: WORKER IMPLEMENTATION ===${NC}"
    
    # Create comprehensive output directories
    mkdir -p "$PROJECT_DIR"/{src,tests,docs,config,scripts,deployments}
    mkdir -p "$PROJECT_DIR"/.github/{workflows,ISSUE_TEMPLATE,PULL_REQUEST_TEMPLATE}
    mkdir -p "$PROJECT_DIR"/src/{components,services,models,controllers,middleware,utils}
    mkdir -p "$PROJECT_DIR"/tests/{unit,integration,e2e}
    mkdir -p "$PROJECT_DIR"/docs/{api,architecture,guides}
    mkdir -p "$PROJECT_DIR"/config/{development,staging,production}
    mkdir -p "$PROJECT_DIR"/scripts/{setup,deploy,migrate}
    mkdir -p "$PROJECT_DIR"/deployments/{docker,kubernetes,terraform}
    
    echo -e "${YELLOW}Launching worker agents for implementation...${NC}"
    
    # Create worker coordination prompt
    cat > "$WORKSPACE_DIR/workers/coordination_prompt.md" << EOF
You are coordinating multiple worker agents for parallel implementation.

**Manager Plans Available**:
- Frontend: $WORKSPACE_DIR/managers/frontend/frontend_plan.md
- Backend: $WORKSPACE_DIR/managers/backend/backend_plan.md
- Database: $WORKSPACE_DIR/managers/database/database_plan.md
- DevOps: $WORKSPACE_DIR/managers/devops/devops_plan.md
- Testing: $WORKSPACE_DIR/managers/testing/testing_plan.md

**Worker Types**:
1. Code Generators - Create source code files
2. Config Writers - Create configuration files
3. Test Writers - Create test files
4. Doc Writers - Create documentation
5. Setup Writers - Create setup and deployment scripts

**Coordination Instructions**:
1. Read all manager plans
2. Extract specific implementation tasks
3. Assign tasks to appropriate worker types
4. Launch workers in parallel (max 10 concurrent)
5. Ensure proper file organization
6. Handle dependencies between tasks

**Output Requirements**:
- All code should follow project conventions and best practices
- Include comprehensive error handling and logging
- Add inline documentation and JSDoc/docstrings
- Create corresponding test files with >90% coverage
- Update project documentation
- Implement security best practices
- Add performance optimizations
- Include accessibility features
- Support internationalization if applicable

**File Organization**:
- Source code: $PROJECT_DIR/src/
- Tests: $PROJECT_DIR/tests/
- Documentation: $PROJECT_DIR/docs/
- Configuration: $PROJECT_DIR/config/
- CI/CD: $PROJECT_DIR/.github/workflows/
- Scripts: $PROJECT_DIR/scripts/
- Deployments: $PROJECT_DIR/deployments/

**Additional Tasks**:
1. Create package.json/requirements.txt with all dependencies
2. Set up pre-commit hooks (.husky, pre-commit)
3. Configure linters and formatters
4. Create Makefile for common tasks
5. Set up database migrations
6. Create seed data scripts
7. Implement health check endpoints
8. Add monitoring and logging setup
9. Create API documentation (OpenAPI/Swagger)
10. Set up error tracking (Sentry integration)

Use step-by-step reasoning and create high-quality, production-ready code.
Follow SOLID principles and appropriate design patterns.
EOF

    cd "$PROJECT_DIR"
    
    # Execute worker coordination
    claude --dangerously-skip-permissions \
        "Read the worker coordination prompt at $WORKSPACE_DIR/workers/coordination_prompt.md.
         
         Coordinate up to 10 parallel worker agents to implement the entire system.
         
         For each component/feature:
         1. Create the main implementation file
         2. Create corresponding test file
         3. Create or update documentation
         4. Create necessary configuration
         
         Focus on creating a complete, working system with:
         - Clean, maintainable code
         - Comprehensive tests
         - Clear documentation
         - Proper error handling
         - Security best practices
         - Performance optimization
         
         Organize files according to the specified structure.
         Report progress as workers complete their tasks." \
        2>&1 | tee "$LOGS_DIR/worker_implementation.log"
    
    echo -e "${GREEN}Worker implementation phase complete${NC}"
}

# Phase 4: Integration and Finalization
run_integration() {
    echo -e "\n${CYAN}=== PHASE 4: INTEGRATION & FINALIZATION ===${NC}"
    
    # Create integration prompt
    cat > "$WORKSPACE_DIR/architect/integration_prompt.md" << EOF
You are the System Architect performing final integration and quality assurance.

**Review the implemented system**:
1. Verify all components are properly integrated
2. Check dependencies and configurations
3. Ensure tests are passing
4. Validate documentation completeness
5. Verify security measures
6. Check performance considerations

**Tasks**:
1. Create integration report (integration_report.md)
2. Update README.md with:
   - Project overview and features
   - Architecture diagram (using mermaid)
   - Quick start guide
   - Detailed setup instructions
   - API documentation links
   - Deployment guide
   - Contributing guidelines
   - License information
3. Create ARCHITECTURE.md with detailed system design
4. Generate docker-compose.yml for local development
5. Create docker-compose.prod.yml for production
6. Create .env.example with all required environment variables
7. Create .env.test for test environment
8. Update CLAUDE.md with final project information
9. Create CHANGELOG.md
10. Create CONTRIBUTING.md
11. Create SECURITY.md
12. Generate API documentation (OpenAPI spec)
13. Create Postman/Insomnia collection
14. Create database schema diagrams
15. Set up GitHub issue and PR templates

**Quality Checks**:
- Code consistency across all components
- Test coverage > 90%
- All tests passing
- Documentation is comprehensive
- Security scan passed
- Performance benchmarks met
- Accessibility standards met (WCAG 2.1)
- Error handling is comprehensive
- Logging is properly configured
- Monitoring is set up
- CI/CD pipeline is working
- Docker builds successfully
- No hardcoded secrets
- All dependencies are up to date
- Code follows linting rules

**Final Setup**:
1. Run all tests: npm test / pytest / go test
2. Run security audit: npm audit / safety check
3. Build Docker images
4. Validate docker-compose files
5. Check all environment variables
6. Verify database migrations
7. Test API endpoints
8. Validate documentation links
EOF

    cd "$PROJECT_DIR"
    
    claude --dangerously-skip-permissions \
        "Read the integration prompt at $WORKSPACE_DIR/architect/integration_prompt.md.
         
         Perform final integration and create all remaining documentation.
         
         Use 3 parallel sub-agents:
         1. Quality Assurance Agent - Review code quality and test coverage
         2. Documentation Agent - Ensure all docs are complete and clear
         3. DevOps Agent - Verify deployment readiness
         
         Create a professional, production-ready system." \
        2>&1 | tee "$LOGS_DIR/integration.log"
    
    echo -e "${GREEN}Integration complete${NC}"
}

# Analyze existing project
analyze_existing_project() {
    echo -e "${BLUE}═══════════════════════════════════════════════════${NC}"
    echo -e "${CYAN}     Claude Code - Existing Project Analysis${NC}"
    echo -e "${BLUE}═══════════════════════════════════════════════════${NC}"
    
    local project_dir="${1:-$(pwd)}"
    cd "$project_dir"
    
    echo -e "${YELLOW}Analyzing project at: $project_dir${NC}"
    
    # Create analysis workspace
    mkdir -p "$WORKSPACE_DIR/analysis"
    
    # Create comprehensive analysis prompt
    cat > "$WORKSPACE_DIR/analysis/project_analysis.md" << EOF
Perform a comprehensive analysis of the existing project in $project_dir.

Analysis Tasks:

1. **Project Structure Analysis**
   - Identify project type (web, api, cli, etc.)
   - Detect technology stack
   - Analyze directory structure
   - List all dependencies

2. **Code Quality Assessment**
   - Check for code smells
   - Identify duplicate code
   - Analyze complexity
   - Review error handling
   - Check test coverage

3. **Performance Analysis**
   - Database query efficiency
   - API response times
   - Bundle sizes
   - Memory usage patterns
   - Caching opportunities

4. **Security Audit**
   - Outdated dependencies
   - Security vulnerabilities
   - Authentication/authorization issues
   - Data validation gaps
   - Exposed secrets

5. **Architecture Review**
   - Design patterns used
   - Scalability issues
   - Technical debt
   - Coupling/cohesion problems

6. **DevOps Assessment**
   - CI/CD pipeline
   - Deployment process
   - Monitoring setup
   - Backup strategies

7. **Documentation Status**
   - README completeness
   - API documentation
   - Code comments
   - Architecture docs

8. **Improvement Recommendations**
   - Priority 1: Critical fixes
   - Priority 2: Major improvements
   - Priority 3: Nice-to-have enhancements
   - Estimated effort for each

Generate the following reports:
1. project_analysis_report.md - Comprehensive analysis
2. improvement_plan.md - Prioritized action items
3. security_audit.md - Security findings
4. performance_report.md - Performance optimization opportunities
5. refactoring_guide.md - Code improvement suggestions
EOF

    # Run analysis
    claude --dangerously-skip-permissions \
        "Read project_analysis.md and analyze the entire project.
         Use multiple sub-agents to analyze different aspects in parallel:
         1. Code Quality Agent - Review code quality and patterns
         2. Security Agent - Perform security audit
         3. Performance Agent - Analyze performance bottlenecks
         4. Architecture Agent - Review system design
         5. DevOps Agent - Check infrastructure and deployment
         
         Generate all requested reports with actionable recommendations." \
        2>&1 | tee "$LOGS_DIR/project_analysis.log"
    
    # Display summary
    if [ -f "$WORKSPACE_DIR/analysis/improvement_plan.md" ]; then
        echo -e "\n${GREEN}Analysis complete!${NC}"
        echo -e "\n${CYAN}Top recommendations:${NC}"
        head -20 "$WORKSPACE_DIR/analysis/improvement_plan.md" | grep -E "^##|^-|^[0-9]\." || true
        
        echo -e "\n${YELLOW}Full reports available in:${NC}"
        echo "- Analysis: $WORKSPACE_DIR/analysis/project_analysis_report.md"
        echo "- Improvements: $WORKSPACE_DIR/analysis/improvement_plan.md"
        echo "- Security: $WORKSPACE_DIR/analysis/security_audit.md"
        echo "- Performance: $WORKSPACE_DIR/analysis/performance_report.md"
    fi
}

# Upgrade existing project with new features
upgrade_existing_project() {
    local requirement="$1"
    local upgrade_type="${2:-feature}" # feature, refactor, optimize, security
    
    echo -e "${BLUE}═══════════════════════════════════════════════════${NC}"
    echo -e "${CYAN}     Claude Code - Project Upgrade${NC}"
    echo -e "${BLUE}═══════════════════════════════════════════════════${NC}"
    
    local project_dir="$(pwd)"
    
    # First analyze the project
    echo -e "${YELLOW}Step 1: Analyzing existing project...${NC}"
    analyze_existing_project "$project_dir"
    
    # Create upgrade plan
    echo -e "\n${YELLOW}Step 2: Planning upgrade...${NC}"
    
    mkdir -p "$WORKSPACE_DIR/upgrade"
    
    cat > "$WORKSPACE_DIR/upgrade/upgrade_plan.md" << EOF
Plan and execute project upgrade based on:

**Upgrade Requirement**: $requirement
**Upgrade Type**: $upgrade_type
**Project Analysis**: $WORKSPACE_DIR/analysis/project_analysis_report.md

Upgrade Planning:

1. **Compatibility Check**
   - Ensure new features don't break existing functionality
   - Check dependency compatibility
   - Plan migration strategy if needed

2. **Implementation Plan**
   - Break down the requirement into tasks
   - Identify affected components
   - Plan integration points
   - Consider backward compatibility

3. **Based on upgrade type**:
   $(case "$upgrade_type" in
     feature)
       echo "- Add new functionality
   - Integrate with existing code
   - Update tests and documentation"
       ;;
     refactor)
       echo "- Improve code structure
   - Apply design patterns
   - Reduce technical debt
   - Maintain functionality"
       ;;
     optimize)
       echo "- Improve performance
   - Optimize database queries
   - Reduce bundle sizes
   - Implement caching"
       ;;
     security)
       echo "- Fix vulnerabilities
   - Update dependencies
   - Implement security best practices
   - Add security tests"
       ;;
   esac)

4. **Testing Strategy**
   - Update existing tests
   - Add new tests for changes
   - Ensure regression testing
   - Performance benchmarks

5. **Documentation Updates**
   - Update README
   - API documentation
   - Migration guide
   - Changelog

Generate:
1. upgrade_plan.md - Detailed upgrade plan
2. migration_guide.md - If breaking changes
3. Updated code files
4. New/updated tests
5. Updated documentation
EOF

    # Execute upgrade
    echo -e "\n${YELLOW}Step 3: Executing upgrade...${NC}"
    
    claude --dangerously-skip-permissions \
        "Read the upgrade plan and existing project analysis.
         
         Execute the upgrade using parallel agents:
         1. Implementation Agent - Add new features/changes
         2. Testing Agent - Update and add tests
         3. Documentation Agent - Update all docs
         4. Integration Agent - Ensure smooth integration
         
         Follow these principles:
         - Preserve existing functionality
         - Maintain code style consistency
         - Add comprehensive tests
         - Update all relevant documentation
         - Consider performance impact
         - Ensure security best practices
         
         Generate a summary of all changes made." \
        2>&1 | tee "$LOGS_DIR/project_upgrade.log"
    
    # Run validation
    echo -e "\n${YELLOW}Step 4: Validating upgrade...${NC}"
    
    # Test the upgraded project
    if [ -f "package.json" ]; then
        npm test 2>/dev/null || echo "Tests need to be run manually"
    elif [ -f "requirements.txt" ]; then
        pytest 2>/dev/null || echo "Tests need to be run manually"
    fi
    
    echo -e "\n${GREEN}Upgrade complete!${NC}"
    echo -e "\n${CYAN}Summary:${NC}"
    echo "- Upgrade plan: $WORKSPACE_DIR/upgrade/upgrade_plan.md"
    echo "- Changes made: Check git diff"
    echo "- Run 'git status' to see all modified files"
    echo -e "\n${YELLOW}Next steps:${NC}"
    echo "1. Review all changes: git diff"
    echo "2. Run tests: npm test / pytest"
    echo "3. Test functionality manually"
    echo "4. Commit changes: git add -A && git commit -m 'feat: $requirement'"
}

# Post-phase: Final Validation and Deployment Prep
run_final_validation() {
    echo -e "\n${CYAN}=== POST-PHASE: FINAL VALIDATION ===${NC}"
    
    cd "$PROJECT_DIR"
    
    # Create validation checklist
    cat > "$WORKSPACE_DIR/architect/validation_checklist.md" << EOF
Perform final validation of the generated system:

1. **Code Quality**
   - Run all linters and fix any issues
   - Check code coverage (must be >90%)
   - Run security scan
   - Check for TODO/FIXME comments

2. **Testing**
   - Run all unit tests
   - Run integration tests
   - Run E2E tests if applicable
   - Performance testing

3. **Documentation**
   - Verify README completeness
   - Check API documentation
   - Validate all links
   - Review code comments

4. **Deployment Readiness**
   - Build Docker images
   - Test docker-compose up
   - Verify all environment variables
   - Check CI/CD pipeline

5. **Security**
   - No hardcoded secrets
   - Proper authentication/authorization
   - HTTPS/TLS configured
   - Security headers set

6. **Create Quick Start Script**
   - One-command setup script
   - Auto-install dependencies
   - Set up database
   - Run migrations
   - Seed initial data

Generate:
- validation_report.md with all check results
- quickstart.sh for easy project setup
- deployment_guide.md with step-by-step instructions
EOF

    claude --dangerously-skip-permissions \
        "Read validation_checklist.md and perform all validations.
         Fix any issues found during validation.
         Create the requested scripts and reports.
         Make sure the project is production-ready." \
        2>&1 | tee "$LOGS_DIR/final_validation.log"
    
    echo -e "${GREEN}Validation complete${NC}"
}

# Main execution function
create_system() {
    local requirement="$1"
    local project_type="$2"
    local tech_stack="$3"
    
    echo -e "${BLUE}═══════════════════════════════════════════════════${NC}"
    echo -e "${CYAN}     Claude Code Auto Architect - System Creation${NC}"
    echo -e "${BLUE}═══════════════════════════════════════════════════${NC}"
    
    # Initialize workspace
    init_workspace
    
    # Log start time
    local start_time=$(date +%s)
    echo -e "${YELLOW}Start time: $(date)${NC}"
    
    # Run phases
    setup_environment "$requirement"
    if run_architect_analysis "$requirement" "$project_type" "$tech_stack"; then
        if run_manager_planning; then
            if run_worker_implementation; then
                if run_integration; then
                    run_final_validation
                fi
            fi
        fi
    fi
    
    # Calculate duration
    local end_time=$(date +%s)
    local duration=$((end_time - start_time))
    local minutes=$((duration / 60))
    local seconds=$((duration % 60))
    
    echo -e "\n${BLUE}═══════════════════════════════════════════════════${NC}"
    echo -e "${GREEN}✨ SYSTEM CREATION COMPLETE! ✨${NC}"
    echo -e "${BLUE}═══════════════════════════════════════════════════${NC}"
    echo -e "${YELLOW}Total time: ${minutes}m ${seconds}s${NC}"
    echo -e "\n${CYAN}Next steps:${NC}"
    echo "1. Review the generated code and documentation"
    echo "2. Quick start: ./quickstart.sh"
    echo "3. Or manual setup:"
    echo "   - Install dependencies: npm install / pip install -r requirements.txt"
    echo "   - Set up environment: cp .env.example .env && edit .env"
    echo "   - Run database setup: docker-compose up -d && npm run migrate"
    echo "   - Run tests: npm test / pytest"
    echo "   - Start development: npm run dev / python manage.py runserver"
    echo "4. Check README.md for detailed instructions"
    echo "5. View API docs: npm run docs / open docs/api/index.html"
    echo "6. Deploy: See deployment_guide.md"
    echo -e "\n${MAGENTA}Generated Files:${NC}"
    echo "- Source code in: src/"
    echo "- Tests in: tests/"
    echo "- Documentation in: docs/"
    echo "- Configuration in: config/"
    echo "- Deployment files in: deployments/"
    echo "- CI/CD in: .github/workflows/"
    echo -e "\n${GREEN}Happy coding! 🚀${NC}"
}

# Parse command line arguments
COMMAND=""
REQUIREMENT=""
PROJECT_TYPE=""
TECH_STACK=""
PARALLEL_AGENTS=10
VERBOSE=false

while [[ $# -gt 0 ]]; do
    case $1 in
        create|analyze|upgrade)
            COMMAND="$1"
            shift
            ;;
        -r|--requirement)
            REQUIREMENT="$2"
            shift 2
            ;;
        -t|--type)
            PROJECT_TYPE="$2"
            shift 2
            ;;
        -s|--stack)
            TECH_STACK="$2"
            shift 2
            ;;
        -p|--parallel)
            PARALLEL_AGENTS="$2"
            shift 2
            ;;
        -v|--verbose)
            VERBOSE=true
            shift
            ;;
        -h|--help)
            usage
            ;;
        *)
            echo -e "${RED}Unknown option: $1${NC}"
            usage
            ;;
    esac
done

# Execute command
case "$COMMAND" in
    create)
        if [ -z "$REQUIREMENT" ]; then
            echo -e "${RED}Error: Requirement is required for create command${NC}"
            echo "Example: $0 create -r \"Task management system with real-time updates\""
            exit 1
        fi
        create_system "$REQUIREMENT" "$PROJECT_TYPE" "$TECH_STACK"
        ;;
    analyze)
        analyze_existing_project
        ;;
    upgrade)
        if [ -z "$REQUIREMENT" ]; then
            echo -e "${RED}Error: Requirement is required for upgrade command${NC}"
            echo "Example: $0 upgrade -r 'Add real-time notifications'"
            echo "Example: $0 upgrade -r 'Optimize database queries' -t optimize"
            echo "Example: $0 upgrade -r 'Fix security vulnerabilities' -t security"
            exit 1
        fi
        upgrade_existing_project "$REQUIREMENT" "$PROJECT_TYPE"
        ;;
    *)
        usage
        ;;
esac