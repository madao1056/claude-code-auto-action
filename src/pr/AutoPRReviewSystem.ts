import * as fs from 'fs';
import * as path from 'path';
import { exec } from 'child_process';
import { promisify } from 'util';
import { Octokit } from '@octokit/rest';
import * as diff from 'diff';

const execAsync = promisify(exec);

interface PRConfig {
  autoReview: boolean;
  autoMerge: boolean;
  requireApprovals: number;
  autoAssignReviewers: boolean;
  autoGenerateDescription: boolean;
  checkConflicts: boolean;
  runTestsBeforeMerge: boolean;
  reviewChecklist: string[];
}

interface ChangeAnalysis {
  filesChanged: number;
  additions: number;
  deletions: number;
  changeType: 'feature' | 'bugfix' | 'refactor' | 'docs' | 'test' | 'chore';
  breakingChanges: boolean;
  testsCoverage: boolean;
  complexity: 'low' | 'medium' | 'high';
}

interface ReviewComment {
  path: string;
  line: number;
  message: string;
  severity: 'info' | 'warning' | 'error';
  suggestion?: string;
}

interface PRDescription {
  title: string;
  body: string;
  labels: string[];
  reviewers: string[];
  assignees: string[];
}

export class AutoPRReviewSystem {
  private config: PRConfig;
  private octokit: Octokit | null = null;
  private projectRoot: string;

  constructor(projectRoot: string, config?: Partial<PRConfig>) {
    this.projectRoot = projectRoot;
    this.config = {
      autoReview: true,
      autoMerge: false,
      requireApprovals: 1,
      autoAssignReviewers: true,
      autoGenerateDescription: true,
      checkConflicts: true,
      runTestsBeforeMerge: true,
      reviewChecklist: [
        'ã‚³ãƒ¼ãƒ‰ã‚¹ã‚¿ã‚¤ãƒ«ãŒä¸€è²«ã—ã¦ã„ã‚‹',
        'ãƒ†ã‚¹ãƒˆãŒè¿½åŠ /æ›´æ–°ã•ã‚Œã¦ã„ã‚‹',
        'ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆãŒæ›´æ–°ã•ã‚Œã¦ã„ã‚‹',
        'ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ã¸ã®å½±éŸ¿ã‚’è€ƒæ…®ã—ã¦ã„ã‚‹',
        'ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒªã‚¹ã‚¯ãŒãªã„',
        'ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ãŒé©åˆ‡',
      ],
      ...config,
    };

    this.initializeGitHub();
  }

  private async initializeGitHub(): Promise<void> {
    try {
      const token = process.env.GITHUB_TOKEN;
      if (token) {
        this.octokit = new Octokit({ auth: token });
      }
    } catch (error) {
      console.warn('GitHub APIã®åˆæœŸåŒ–ã«å¤±æ•—ã—ã¾ã—ãŸ:', error);
    }
  }

  async createPR(targetBranch: string = 'main'): Promise<void> {
    console.log('ğŸš€ Pull Requestã‚’ä½œæˆä¸­...');

    // ç¾åœ¨ã®ãƒ–ãƒ©ãƒ³ãƒã‚’å–å¾—
    const currentBranch = await this.getCurrentBranch();
    if (currentBranch === targetBranch) {
      throw new Error('ç¾åœ¨ã®ãƒ–ãƒ©ãƒ³ãƒãŒã‚¿ãƒ¼ã‚²ãƒƒãƒˆãƒ–ãƒ©ãƒ³ãƒã¨åŒã˜ã§ã™');
    }

    // å¤‰æ›´ã‚’è§£æ
    const analysis = await this.analyzeChanges(targetBranch);

    // PRèª¬æ˜ã‚’ç”Ÿæˆ
    const description = await this.generatePRDescription(analysis, currentBranch, targetBranch);

    // PRã‚’ä½œæˆ
    if (this.octokit) {
      await this.createGitHubPR(description, currentBranch, targetBranch);
    } else {
      await this.createLocalPR(description, currentBranch, targetBranch);
    }

    console.log('âœ… Pull RequestãŒä½œæˆã•ã‚Œã¾ã—ãŸ');
  }

  private async getCurrentBranch(): Promise<string> {
    const { stdout } = await execAsync('git branch --show-current', { cwd: this.projectRoot });
    return stdout.trim();
  }

  private async analyzeChanges(targetBranch: string): Promise<ChangeAnalysis> {
    const { stdout: diffStat } = await execAsync(`git diff ${targetBranch}...HEAD --stat`, {
      cwd: this.projectRoot,
    });

    const { stdout: diffContent } = await execAsync(`git diff ${targetBranch}...HEAD`, {
      cwd: this.projectRoot,
    });

    // çµ±è¨ˆæƒ…å ±ã‚’è§£æ
    const statMatch = diffStat.match(
      /(\d+) files? changed(?:, (\d+) insertions?\(\+\))?(?:, (\d+) deletions?\(-\))?/
    );
    const filesChanged = parseInt(statMatch?.[1] || '0');
    const additions = parseInt(statMatch?.[2] || '0');
    const deletions = parseInt(statMatch?.[3] || '0');

    // å¤‰æ›´ã‚¿ã‚¤ãƒ—ã‚’æ¨å®š
    const changeType = this.detectChangeType(diffContent);

    // ç ´å£Šçš„å¤‰æ›´ã‚’ãƒã‚§ãƒƒã‚¯
    const breakingChanges = this.detectBreakingChanges(diffContent);

    // ãƒ†ã‚¹ãƒˆã®æœ‰ç„¡ã‚’ãƒã‚§ãƒƒã‚¯
    const testsCoverage = diffContent.includes('.test.') || diffContent.includes('.spec.');

    // è¤‡é›‘åº¦ã‚’è¨ˆç®—
    const complexity = this.calculateComplexity(filesChanged, additions, deletions);

    return {
      filesChanged,
      additions,
      deletions,
      changeType,
      breakingChanges,
      testsCoverage,
      complexity,
    };
  }

  private detectChangeType(diffContent: string): ChangeAnalysis['changeType'] {
    if (diffContent.includes('fix:') || diffContent.includes('bugfix:')) {
      return 'bugfix';
    } else if (diffContent.includes('feat:') || diffContent.includes('feature:')) {
      return 'feature';
    } else if (diffContent.includes('refactor:')) {
      return 'refactor';
    } else if (diffContent.includes('docs:') || diffContent.includes('.md')) {
      return 'docs';
    } else if (
      diffContent.includes('test:') ||
      diffContent.includes('.test.') ||
      diffContent.includes('.spec.')
    ) {
      return 'test';
    }
    return 'chore';
  }

  private detectBreakingChanges(diffContent: string): boolean {
    const breakingPatterns = [
      /BREAKING CHANGE:/i,
      /removed\s+public\s+API/i,
      /changed\s+signature/i,
      /deprecated/i,
    ];

    return breakingPatterns.some((pattern) => pattern.test(diffContent));
  }

  private calculateComplexity(
    filesChanged: number,
    additions: number,
    deletions: number
  ): 'low' | 'medium' | 'high' {
    const totalChanges = additions + deletions;

    if (filesChanged > 20 || totalChanges > 500) {
      return 'high';
    } else if (filesChanged > 10 || totalChanges > 200) {
      return 'medium';
    }
    return 'low';
  }

  private async generatePRDescription(
    analysis: ChangeAnalysis,
    sourceBranch: string,
    targetBranch: string
  ): Promise<PRDescription> {
    // ã‚³ãƒŸãƒƒãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’å–å¾—
    const { stdout: commits } = await execAsync(
      `git log ${targetBranch}..HEAD --pretty=format:"%s" --reverse`,
      { cwd: this.projectRoot }
    );

    const commitList = commits.split('\n').filter(Boolean);

    // ã‚¿ã‚¤ãƒˆãƒ«ã‚’ç”Ÿæˆ
    const title = this.generateTitle(commitList, analysis);

    // æœ¬æ–‡ã‚’ç”Ÿæˆ
    const body = this.generateBody(analysis, commitList);

    // ãƒ©ãƒ™ãƒ«ã‚’æ±ºå®š
    const labels = this.determineLabels(analysis);

    // ãƒ¬ãƒ“ãƒ¥ã‚¢ãƒ¼ã‚’é¸å®š
    const reviewers = await this.selectReviewers(analysis);

    return {
      title,
      body,
      labels,
      reviewers,
      assignees: [],
    };
  }

  private generateTitle(commits: string[], analysis: ChangeAnalysis): string {
    if (commits.length === 1) {
      return commits[0];
    }

    const typeEmoji = {
      feature: 'âœ¨',
      bugfix: 'ğŸ›',
      refactor: 'â™»ï¸',
      docs: 'ğŸ“š',
      test: 'ğŸ§ª',
      chore: 'ğŸ”§',
    };

    const emoji = typeEmoji[analysis.changeType] || 'ğŸš€';
    const type = analysis.changeType.charAt(0).toUpperCase() + analysis.changeType.slice(1);

    return `${emoji} ${type}: ${this.summarizeCommits(commits)}`;
  }

  private summarizeCommits(commits: string[]): string {
    // ã‚³ãƒŸãƒƒãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‹ã‚‰å…±é€šã®ãƒ†ãƒ¼ãƒã‚’æŠ½å‡º
    const keywords = new Map<string, number>();

    for (const commit of commits) {
      const words = commit.toLowerCase().split(/\s+/);
      for (const word of words) {
        if (word.length > 3 && !['feat', 'fix', 'chore', 'docs', 'test'].includes(word)) {
          keywords.set(word, (keywords.get(word) || 0) + 1);
        }
      }
    }

    // æœ€ã‚‚é »å‡ºã™ã‚‹ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’ä½¿ç”¨
    const sortedKeywords = Array.from(keywords.entries())
      .sort((a, b) => b[1] - a[1])
      .slice(0, 3)
      .map(([word]) => word);

    return sortedKeywords.join(', ') || 'Multiple improvements';
  }

  private generateBody(analysis: ChangeAnalysis, commits: string[]): string {
    let body = '## Summary\n\n';

    // å¤‰æ›´ã®æ¦‚è¦
    body += `This PR includes ${analysis.filesChanged} file(s) with +${analysis.additions}/-${analysis.deletions} changes.\n\n`;

    // å¤‰æ›´å†…å®¹
    body += '## Changes\n\n';
    for (const commit of commits) {
      body += `- ${commit}\n`;
    }
    body += '\n';

    // ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ
    if (this.config.reviewChecklist.length > 0) {
      body += '## Checklist\n\n';
      for (const item of this.config.reviewChecklist) {
        const checked = this.checkItem(item, analysis) ? 'x' : ' ';
        body += `- [${checked}] ${item}\n`;
      }
      body += '\n';
    }

    // è¿½åŠ æƒ…å ±
    if (analysis.breakingChanges) {
      body += '## âš ï¸ Breaking Changes\n\n';
      body += 'This PR contains breaking changes. Please review carefully.\n\n';
    }

    if (!analysis.testsCoverage) {
      body += '## ğŸ“ Note\n\n';
      body += 'No test changes detected. Please ensure adequate test coverage.\n\n';
    }

    // ãƒ•ãƒƒã‚¿ãƒ¼
    body += '---\n';
    body += 'ğŸ¤– Generated with Claude Code Auto Action\n';

    return body;
  }

  private checkItem(item: string, analysis: ChangeAnalysis): boolean {
    if (item.includes('ãƒ†ã‚¹ãƒˆ') && analysis.testsCoverage) return true;
    if (item.includes('ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ') && analysis.changeType === 'docs') return true;
    if (item.includes('ã‚³ãƒ¼ãƒ‰ã‚¹ã‚¿ã‚¤ãƒ«')) return true; // è‡ªå‹•ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆæ¸ˆã¿ã¨ä»®å®š
    return false;
  }

  private determineLabels(analysis: ChangeAnalysis): string[] {
    const labels: string[] = [];

    // å¤‰æ›´ã‚¿ã‚¤ãƒ—
    labels.push(analysis.changeType);

    // è¤‡é›‘åº¦
    if (analysis.complexity === 'high') {
      labels.push('large-pr');
    } else if (analysis.complexity === 'medium') {
      labels.push('medium-pr');
    } else {
      labels.push('small-pr');
    }

    // ç‰¹æ®Šãªãƒ©ãƒ™ãƒ«
    if (analysis.breakingChanges) {
      labels.push('breaking-change');
    }

    if (!analysis.testsCoverage) {
      labels.push('needs-tests');
    }

    return labels;
  }

  private async selectReviewers(analysis: ChangeAnalysis): Promise<string[]> {
    if (!this.config.autoAssignReviewers) {
      return [];
    }

    // CODEOWNERSãƒ•ã‚¡ã‚¤ãƒ«ã‚’ç¢ºèª
    const codeownersPath = path.join(this.projectRoot, '.github', 'CODEOWNERS');
    if (fs.existsSync(codeownersPath)) {
      const owners = await this.parseCodeowners(codeownersPath);
      return owners.slice(0, 2); // æœ€å¤§2äºº
    }

    // ãƒãƒ¼ãƒ ãƒ¡ãƒ³ãƒãƒ¼ã‹ã‚‰é¸å®šï¼ˆè¨­å®šã‹ã‚‰å–å¾—ï¼‰
    return [];
  }

  private async parseCodeowners(filePath: string): Promise<string[]> {
    const content = fs.readFileSync(filePath, 'utf-8');
    const owners = new Set<string>();

    const lines = content.split('\n');
    for (const line of lines) {
      if (!line.startsWith('#') && line.trim()) {
        const parts = line.split(/\s+/);
        for (let i = 1; i < parts.length; i++) {
          if (parts[i].startsWith('@')) {
            owners.add(parts[i].substring(1));
          }
        }
      }
    }

    return Array.from(owners);
  }

  private async createGitHubPR(
    description: PRDescription,
    sourceBranch: string,
    targetBranch: string
  ): Promise<void> {
    if (!this.octokit) {
      throw new Error('GitHub APIãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã¾ã›ã‚“');
    }

    // ãƒªãƒã‚¸ãƒˆãƒªæƒ…å ±ã‚’å–å¾—
    const { stdout } = await execAsync('git remote get-url origin', { cwd: this.projectRoot });
    const match = stdout.match(/github\.com[:/](.+?)\/(.+?)(?:\.git)?$/);

    if (!match) {
      throw new Error('GitHubãƒªãƒã‚¸ãƒˆãƒªã®URLã‚’è§£æã§ãã¾ã›ã‚“');
    }

    const [, owner, repo] = match;

    // PRã‚’ä½œæˆ
    const { data: pr } = await this.octokit.pulls.create({
      owner,
      repo: repo.replace('.git', ''),
      title: description.title,
      head: sourceBranch,
      base: targetBranch,
      body: description.body,
    });

    // ãƒ©ãƒ™ãƒ«ã‚’è¿½åŠ 
    if (description.labels.length > 0) {
      await this.octokit.issues.addLabels({
        owner,
        repo: repo.replace('.git', ''),
        issue_number: pr.number,
        labels: description.labels,
      });
    }

    // ãƒ¬ãƒ“ãƒ¥ã‚¢ãƒ¼ã‚’è¿½åŠ 
    if (description.reviewers.length > 0) {
      await this.octokit.pulls.requestReviewers({
        owner,
        repo: repo.replace('.git', ''),
        pull_number: pr.number,
        reviewers: description.reviewers,
      });
    }

    console.log(`âœ… PR #${pr.number} ãŒä½œæˆã•ã‚Œã¾ã—ãŸ: ${pr.html_url}`);
  }

  private async createLocalPR(
    description: PRDescription,
    sourceBranch: string,
    targetBranch: string
  ): Promise<void> {
    // ãƒ­ãƒ¼ã‚«ãƒ«ã§PRæƒ…å ±ã‚’ä¿å­˜
    const prDir = path.join(this.projectRoot, '.github', 'pull_requests');
    if (!fs.existsSync(prDir)) {
      fs.mkdirSync(prDir, { recursive: true });
    }

    const prData = {
      title: description.title,
      body: description.body,
      source: sourceBranch,
      target: targetBranch,
      labels: description.labels,
      reviewers: description.reviewers,
      created: new Date().toISOString(),
    };

    const prFile = path.join(prDir, `${sourceBranch}-to-${targetBranch}.json`);
    fs.writeFileSync(prFile, JSON.stringify(prData, null, 2));

    console.log(`âœ… ãƒ­ãƒ¼ã‚«ãƒ«PRæƒ…å ±ãŒä¿å­˜ã•ã‚Œã¾ã—ãŸ: ${prFile}`);
  }

  async reviewPR(prNumber: number): Promise<ReviewComment[]> {
    console.log(`ğŸ” PR #${prNumber} ã‚’ãƒ¬ãƒ“ãƒ¥ãƒ¼ä¸­...`);

    const comments: ReviewComment[] = [];

    // PRã®å¤‰æ›´ã‚’å–å¾—
    const changes = await this.getPRChanges(prNumber);

    // å„ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ãƒ¬ãƒ“ãƒ¥ãƒ¼
    for (const file of changes) {
      const fileComments = await this.reviewFile(file);
      comments.push(...fileComments);
    }

    // è‡ªå‹•ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚³ãƒ¡ãƒ³ãƒˆã‚’æŠ•ç¨¿
    if (this.config.autoReview && comments.length > 0) {
      await this.postReviewComments(prNumber, comments);
    }

    return comments;
  }

  private async getPRChanges(prNumber: number): Promise<any[]> {
    // å®Ÿéš›ã®å®Ÿè£…ã§ã¯GitHub APIã¾ãŸã¯ãƒ­ãƒ¼ã‚«ãƒ«gitã‚’ä½¿ç”¨
    return [];
  }

  private async reviewFile(file: any): Promise<ReviewComment[]> {
    const comments: ReviewComment[] = [];
    const content = file.patch || '';

    // ã‚³ãƒ¼ãƒ‰ã‚¹ã‚¿ã‚¤ãƒ«ãƒã‚§ãƒƒã‚¯
    if (file.filename.endsWith('.js') || file.filename.endsWith('.ts')) {
      // ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆãƒã‚§ãƒƒã‚¯
      const lines = content.split('\n');
      lines.forEach((line, index) => {
        if (line.startsWith('+') && line.includes('\t')) {
          comments.push({
            path: file.filename,
            line: index + 1,
            message: 'ã‚¿ãƒ–ã®ä»£ã‚ã‚Šã«ã‚¹ãƒšãƒ¼ã‚¹ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„',
            severity: 'warning',
          });
        }
      });

      // console.logãƒã‚§ãƒƒã‚¯
      if (content.includes('console.log')) {
        comments.push({
          path: file.filename,
          line: 1,
          message: 'console.logãŒæ®‹ã£ã¦ã„ã¾ã™ã€‚å‰Šé™¤ã—ã¦ãã ã•ã„',
          severity: 'warning',
        });
      }

      // TODOã‚³ãƒ¡ãƒ³ãƒˆãƒã‚§ãƒƒã‚¯
      if (content.includes('TODO')) {
        comments.push({
          path: file.filename,
          line: 1,
          message: 'TODOã‚³ãƒ¡ãƒ³ãƒˆãŒã‚ã‚Šã¾ã™ã€‚issueã‚’ä½œæˆã™ã‚‹ã“ã¨ã‚’æ¤œè¨ã—ã¦ãã ã•ã„',
          severity: 'info',
        });
      }
    }

    // ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒã‚§ãƒƒã‚¯
    const securityPatterns = [
      { pattern: /password\s*=\s*["']/, message: 'ãƒãƒ¼ãƒ‰ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãŒæ¤œå‡ºã•ã‚Œã¾ã—ãŸ' },
      { pattern: /api[_-]?key\s*=\s*["']/, message: 'ãƒãƒ¼ãƒ‰ã‚³ãƒ¼ãƒ‰ã•ã‚ŒãŸAPIã‚­ãƒ¼ãŒæ¤œå‡ºã•ã‚Œã¾ã—ãŸ' },
      { pattern: /eval\(/, message: 'eval()ã®ä½¿ç”¨ã¯é¿ã‘ã¦ãã ã•ã„' },
    ];

    for (const { pattern, message } of securityPatterns) {
      if (pattern.test(content)) {
        comments.push({
          path: file.filename,
          line: 1,
          message,
          severity: 'error',
        });
      }
    }

    return comments;
  }

  private async postReviewComments(prNumber: number, comments: ReviewComment[]): Promise<void> {
    if (!this.octokit) return;

    // ã‚³ãƒ¡ãƒ³ãƒˆã‚’ã‚°ãƒ«ãƒ¼ãƒ—åŒ–
    const reviewComments = comments.map((comment) => ({
      path: comment.path,
      line: comment.line,
      body: `${this.getSeverityEmoji(comment.severity)} ${comment.message}`,
    }));

    // ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’æŠ•ç¨¿ï¼ˆå®Ÿéš›ã®å®Ÿè£…ï¼‰
    console.log(`ğŸ“ ${comments.length}ä»¶ã®ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚³ãƒ¡ãƒ³ãƒˆã‚’æŠ•ç¨¿ã—ã¾ã—ãŸ`);
  }

  private getSeverityEmoji(severity: ReviewComment['severity']): string {
    const emojis = {
      info: 'â„¹ï¸',
      warning: 'âš ï¸',
      error: 'âŒ',
    };
    return emojis[severity];
  }

  async handleReviewComments(prNumber: number): Promise<void> {
    console.log(`ğŸ’¬ PR #${prNumber} ã®ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚³ãƒ¡ãƒ³ãƒˆã«å¯¾å¿œä¸­...`);

    // ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚³ãƒ¡ãƒ³ãƒˆã‚’å–å¾—
    const comments = await this.getReviewComments(prNumber);

    // å„ã‚³ãƒ¡ãƒ³ãƒˆã«å¯¾ã—ã¦è‡ªå‹•ä¿®æ­£ã‚’è©¦ã¿ã‚‹
    for (const comment of comments) {
      await this.handleSingleComment(comment);
    }

    console.log('âœ… ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚³ãƒ¡ãƒ³ãƒˆã¸ã®å¯¾å¿œãŒå®Œäº†ã—ã¾ã—ãŸ');
  }

  private async getReviewComments(prNumber: number): Promise<any[]> {
    // å®Ÿéš›ã®å®Ÿè£…ã§ã¯GitHub APIã‚’ä½¿ç”¨
    return [];
  }

  private async handleSingleComment(comment: any): Promise<void> {
    // ã‚³ãƒ¡ãƒ³ãƒˆã®å†…å®¹ã‹ã‚‰ä¿®æ­£æ–¹æ³•ã‚’åˆ¤æ–­
    const message = comment.body.toLowerCase();

    if (message.includes('ã‚¹ãƒšãƒ¼ã‚¹') || message.includes('indent')) {
      // ã‚¤ãƒ³ãƒ‡ãƒ³ãƒˆä¿®æ­£
      await this.fixIndentation(comment.path);
    } else if (message.includes('console.log')) {
      // console.logå‰Šé™¤
      await this.removeConsoleLogs(comment.path);
    } else if (message.includes('test')) {
      // ãƒ†ã‚¹ãƒˆè¿½åŠ 
      console.log('ãƒ†ã‚¹ãƒˆã®è¿½åŠ ãŒå¿…è¦ã§ã™');
    }
  }

  private async fixIndentation(filePath: string): Promise<void> {
    const fullPath = path.join(this.projectRoot, filePath);
    if (fs.existsSync(fullPath)) {
      const content = fs.readFileSync(fullPath, 'utf-8');
      const fixed = content.replace(/\t/g, '  ');
      fs.writeFileSync(fullPath, fixed);
    }
  }

  private async removeConsoleLogs(filePath: string): Promise<void> {
    const fullPath = path.join(this.projectRoot, filePath);
    if (fs.existsSync(fullPath)) {
      const content = fs.readFileSync(fullPath, 'utf-8');
      const fixed = content.replace(/console\.log\([^)]*\);?\n?/g, '');
      fs.writeFileSync(fullPath, fixed);
    }
  }

  async checkMergeability(prNumber: number): Promise<boolean> {
    console.log(`ğŸ” PR #${prNumber} ã®ãƒãƒ¼ã‚¸å¯èƒ½æ€§ã‚’ãƒã‚§ãƒƒã‚¯ä¸­...`);

    const checks = {
      conflicts: false,
      testsPass: false,
      approved: false,
      ciPassed: false,
    };

    // ã‚³ãƒ³ãƒ•ãƒªã‚¯ãƒˆãƒã‚§ãƒƒã‚¯
    if (this.config.checkConflicts) {
      checks.conflicts = await this.checkConflicts(prNumber);
    }

    // ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
    if (this.config.runTestsBeforeMerge) {
      checks.testsPass = await this.runTests();
    }

    // æ‰¿èªãƒã‚§ãƒƒã‚¯
    checks.approved = await this.checkApprovals(prNumber);

    // CI/CDãƒã‚§ãƒƒã‚¯
    checks.ciPassed = await this.checkCIStatus(prNumber);

    const canMerge = !checks.conflicts && checks.testsPass && checks.approved && checks.ciPassed;

    if (canMerge) {
      console.log('âœ… PRã¯ãƒãƒ¼ã‚¸å¯èƒ½ã§ã™');
    } else {
      console.log('âŒ PRã¯ã¾ã ãƒãƒ¼ã‚¸ã§ãã¾ã›ã‚“:');
      if (checks.conflicts) console.log('  - ã‚³ãƒ³ãƒ•ãƒªã‚¯ãƒˆãŒã‚ã‚Šã¾ã™');
      if (!checks.testsPass) console.log('  - ãƒ†ã‚¹ãƒˆãŒå¤±æ•—ã—ã¦ã„ã¾ã™');
      if (!checks.approved) console.log('  - æ‰¿èªãŒä¸è¶³ã—ã¦ã„ã¾ã™');
      if (!checks.ciPassed) console.log('  - CI/CDãŒå¤±æ•—ã—ã¦ã„ã¾ã™');
    }

    return canMerge;
  }

  private async checkConflicts(prNumber: number): Promise<boolean> {
    // å®Ÿéš›ã®å®Ÿè£…ã§ã¯GitHub APIã¾ãŸã¯gitã‚³ãƒãƒ³ãƒ‰ã‚’ä½¿ç”¨
    return false;
  }

  private async runTests(): Promise<boolean> {
    try {
      await execAsync('npm test', { cwd: this.projectRoot });
      return true;
    } catch {
      return false;
    }
  }

  private async checkApprovals(prNumber: number): Promise<boolean> {
    // å®Ÿéš›ã®å®Ÿè£…ã§ã¯GitHub APIã‚’ä½¿ç”¨
    return true;
  }

  private async checkCIStatus(prNumber: number): Promise<boolean> {
    // å®Ÿéš›ã®å®Ÿè£…ã§ã¯GitHub APIã‚’ä½¿ç”¨
    return true;
  }
}
