import * as fs from 'fs';
import * as path from 'path';
import { exec } from 'child_process';
import { promisify } from 'util';
import { Octokit } from '@octokit/rest';
import * as diff from 'diff';

const execAsync = promisify(exec);

interface PRConfig {
  autoReview: boolean;
  autoMerge: boolean;
  requireApprovals: number;
  autoAssignReviewers: boolean;
  autoGenerateDescription: boolean;
  checkConflicts: boolean;
  runTestsBeforeMerge: boolean;
  reviewChecklist: string[];
}

interface ChangeAnalysis {
  filesChanged: number;
  additions: number;
  deletions: number;
  changeType: 'feature' | 'bugfix' | 'refactor' | 'docs' | 'test' | 'chore';
  breakingChanges: boolean;
  testsCoverage: boolean;
  complexity: 'low' | 'medium' | 'high';
}

interface ReviewComment {
  path: string;
  line: number;
  message: string;
  severity: 'info' | 'warning' | 'error';
  suggestion?: string;
}

interface PRDescription {
  title: string;
  body: string;
  labels: string[];
  reviewers: string[];
  assignees: string[];
}

export class AutoPRReviewSystem {
  private config: PRConfig;
  private octokit: Octokit | null = null;
  private projectRoot: string;

  constructor(projectRoot: string, config?: Partial<PRConfig>) {
    this.projectRoot = projectRoot;
    this.config = {
      autoReview: true,
      autoMerge: false,
      requireApprovals: 1,
      autoAssignReviewers: true,
      autoGenerateDescription: true,
      checkConflicts: true,
      runTestsBeforeMerge: true,
      reviewChecklist: [
        'コードスタイルが一貫している',
        'テストが追加/更新されている',
        'ドキュメントが更新されている',
        'パフォーマンスへの影響を考慮している',
        'セキュリティリスクがない',
        'エラーハンドリングが適切',
      ],
      ...config,
    };

    this.initializeGitHub();
  }

  private async initializeGitHub(): Promise<void> {
    try {
      const token = process.env.GITHUB_TOKEN;
      if (token) {
        this.octokit = new Octokit({ auth: token });
      }
    } catch (error) {
      console.warn('GitHub APIの初期化に失敗しました:', error);
    }
  }

  async createPR(targetBranch: string = 'main'): Promise<void> {
    console.log('🚀 Pull Requestを作成中...');

    // 現在のブランチを取得
    const currentBranch = await this.getCurrentBranch();
    if (currentBranch === targetBranch) {
      throw new Error('現在のブランチがターゲットブランチと同じです');
    }

    // 変更を解析
    const analysis = await this.analyzeChanges(targetBranch);

    // PR説明を生成
    const description = await this.generatePRDescription(analysis, currentBranch, targetBranch);

    // PRを作成
    if (this.octokit) {
      await this.createGitHubPR(description, currentBranch, targetBranch);
    } else {
      await this.createLocalPR(description, currentBranch, targetBranch);
    }

    console.log('✅ Pull Requestが作成されました');
  }

  private async getCurrentBranch(): Promise<string> {
    const { stdout } = await execAsync('git branch --show-current', { cwd: this.projectRoot });
    return stdout.trim();
  }

  private async analyzeChanges(targetBranch: string): Promise<ChangeAnalysis> {
    const { stdout: diffStat } = await execAsync(`git diff ${targetBranch}...HEAD --stat`, {
      cwd: this.projectRoot,
    });

    const { stdout: diffContent } = await execAsync(`git diff ${targetBranch}...HEAD`, {
      cwd: this.projectRoot,
    });

    // 統計情報を解析
    const statMatch = diffStat.match(
      /(\d+) files? changed(?:, (\d+) insertions?\(\+\))?(?:, (\d+) deletions?\(-\))?/
    );
    const filesChanged = parseInt(statMatch?.[1] || '0');
    const additions = parseInt(statMatch?.[2] || '0');
    const deletions = parseInt(statMatch?.[3] || '0');

    // 変更タイプを推定
    const changeType = this.detectChangeType(diffContent);

    // 破壊的変更をチェック
    const breakingChanges = this.detectBreakingChanges(diffContent);

    // テストの有無をチェック
    const testsCoverage = diffContent.includes('.test.') || diffContent.includes('.spec.');

    // 複雑度を計算
    const complexity = this.calculateComplexity(filesChanged, additions, deletions);

    return {
      filesChanged,
      additions,
      deletions,
      changeType,
      breakingChanges,
      testsCoverage,
      complexity,
    };
  }

  private detectChangeType(diffContent: string): ChangeAnalysis['changeType'] {
    if (diffContent.includes('fix:') || diffContent.includes('bugfix:')) {
      return 'bugfix';
    } else if (diffContent.includes('feat:') || diffContent.includes('feature:')) {
      return 'feature';
    } else if (diffContent.includes('refactor:')) {
      return 'refactor';
    } else if (diffContent.includes('docs:') || diffContent.includes('.md')) {
      return 'docs';
    } else if (
      diffContent.includes('test:') ||
      diffContent.includes('.test.') ||
      diffContent.includes('.spec.')
    ) {
      return 'test';
    }
    return 'chore';
  }

  private detectBreakingChanges(diffContent: string): boolean {
    const breakingPatterns = [
      /BREAKING CHANGE:/i,
      /removed\s+public\s+API/i,
      /changed\s+signature/i,
      /deprecated/i,
    ];

    return breakingPatterns.some((pattern) => pattern.test(diffContent));
  }

  private calculateComplexity(
    filesChanged: number,
    additions: number,
    deletions: number
  ): 'low' | 'medium' | 'high' {
    const totalChanges = additions + deletions;

    if (filesChanged > 20 || totalChanges > 500) {
      return 'high';
    } else if (filesChanged > 10 || totalChanges > 200) {
      return 'medium';
    }
    return 'low';
  }

  private async generatePRDescription(
    analysis: ChangeAnalysis,
    sourceBranch: string,
    targetBranch: string
  ): Promise<PRDescription> {
    // コミットメッセージを取得
    const { stdout: commits } = await execAsync(
      `git log ${targetBranch}..HEAD --pretty=format:"%s" --reverse`,
      { cwd: this.projectRoot }
    );

    const commitList = commits.split('\n').filter(Boolean);

    // タイトルを生成
    const title = this.generateTitle(commitList, analysis);

    // 本文を生成
    const body = this.generateBody(analysis, commitList);

    // ラベルを決定
    const labels = this.determineLabels(analysis);

    // レビュアーを選定
    const reviewers = await this.selectReviewers(analysis);

    return {
      title,
      body,
      labels,
      reviewers,
      assignees: [],
    };
  }

  private generateTitle(commits: string[], analysis: ChangeAnalysis): string {
    if (commits.length === 1) {
      return commits[0];
    }

    const typeEmoji = {
      feature: '✨',
      bugfix: '🐛',
      refactor: '♻️',
      docs: '📚',
      test: '🧪',
      chore: '🔧',
    };

    const emoji = typeEmoji[analysis.changeType] || '🚀';
    const type = analysis.changeType.charAt(0).toUpperCase() + analysis.changeType.slice(1);

    return `${emoji} ${type}: ${this.summarizeCommits(commits)}`;
  }

  private summarizeCommits(commits: string[]): string {
    // コミットメッセージから共通のテーマを抽出
    const keywords = new Map<string, number>();

    for (const commit of commits) {
      const words = commit.toLowerCase().split(/\s+/);
      for (const word of words) {
        if (word.length > 3 && !['feat', 'fix', 'chore', 'docs', 'test'].includes(word)) {
          keywords.set(word, (keywords.get(word) || 0) + 1);
        }
      }
    }

    // 最も頻出するキーワードを使用
    const sortedKeywords = Array.from(keywords.entries())
      .sort((a, b) => b[1] - a[1])
      .slice(0, 3)
      .map(([word]) => word);

    return sortedKeywords.join(', ') || 'Multiple improvements';
  }

  private generateBody(analysis: ChangeAnalysis, commits: string[]): string {
    let body = '## Summary\n\n';

    // 変更の概要
    body += `This PR includes ${analysis.filesChanged} file(s) with +${analysis.additions}/-${analysis.deletions} changes.\n\n`;

    // 変更内容
    body += '## Changes\n\n';
    for (const commit of commits) {
      body += `- ${commit}\n`;
    }
    body += '\n';

    // チェックリスト
    if (this.config.reviewChecklist.length > 0) {
      body += '## Checklist\n\n';
      for (const item of this.config.reviewChecklist) {
        const checked = this.checkItem(item, analysis) ? 'x' : ' ';
        body += `- [${checked}] ${item}\n`;
      }
      body += '\n';
    }

    // 追加情報
    if (analysis.breakingChanges) {
      body += '## ⚠️ Breaking Changes\n\n';
      body += 'This PR contains breaking changes. Please review carefully.\n\n';
    }

    if (!analysis.testsCoverage) {
      body += '## 📝 Note\n\n';
      body += 'No test changes detected. Please ensure adequate test coverage.\n\n';
    }

    // フッター
    body += '---\n';
    body += '🤖 Generated with Claude Code Auto Action\n';

    return body;
  }

  private checkItem(item: string, analysis: ChangeAnalysis): boolean {
    if (item.includes('テスト') && analysis.testsCoverage) return true;
    if (item.includes('ドキュメント') && analysis.changeType === 'docs') return true;
    if (item.includes('コードスタイル')) return true; // 自動フォーマット済みと仮定
    return false;
  }

  private determineLabels(analysis: ChangeAnalysis): string[] {
    const labels: string[] = [];

    // 変更タイプ
    labels.push(analysis.changeType);

    // 複雑度
    if (analysis.complexity === 'high') {
      labels.push('large-pr');
    } else if (analysis.complexity === 'medium') {
      labels.push('medium-pr');
    } else {
      labels.push('small-pr');
    }

    // 特殊なラベル
    if (analysis.breakingChanges) {
      labels.push('breaking-change');
    }

    if (!analysis.testsCoverage) {
      labels.push('needs-tests');
    }

    return labels;
  }

  private async selectReviewers(analysis: ChangeAnalysis): Promise<string[]> {
    if (!this.config.autoAssignReviewers) {
      return [];
    }

    // CODEOWNERSファイルを確認
    const codeownersPath = path.join(this.projectRoot, '.github', 'CODEOWNERS');
    if (fs.existsSync(codeownersPath)) {
      const owners = await this.parseCodeowners(codeownersPath);
      return owners.slice(0, 2); // 最大2人
    }

    // チームメンバーから選定（設定から取得）
    return [];
  }

  private async parseCodeowners(filePath: string): Promise<string[]> {
    const content = fs.readFileSync(filePath, 'utf-8');
    const owners = new Set<string>();

    const lines = content.split('\n');
    for (const line of lines) {
      if (!line.startsWith('#') && line.trim()) {
        const parts = line.split(/\s+/);
        for (let i = 1; i < parts.length; i++) {
          if (parts[i].startsWith('@')) {
            owners.add(parts[i].substring(1));
          }
        }
      }
    }

    return Array.from(owners);
  }

  private async createGitHubPR(
    description: PRDescription,
    sourceBranch: string,
    targetBranch: string
  ): Promise<void> {
    if (!this.octokit) {
      throw new Error('GitHub APIが初期化されていません');
    }

    // リポジトリ情報を取得
    const { stdout } = await execAsync('git remote get-url origin', { cwd: this.projectRoot });
    const match = stdout.match(/github\.com[:/](.+?)\/(.+?)(?:\.git)?$/);

    if (!match) {
      throw new Error('GitHubリポジトリのURLを解析できません');
    }

    const [, owner, repo] = match;

    // PRを作成
    const { data: pr } = await this.octokit.pulls.create({
      owner,
      repo: repo.replace('.git', ''),
      title: description.title,
      head: sourceBranch,
      base: targetBranch,
      body: description.body,
    });

    // ラベルを追加
    if (description.labels.length > 0) {
      await this.octokit.issues.addLabels({
        owner,
        repo: repo.replace('.git', ''),
        issue_number: pr.number,
        labels: description.labels,
      });
    }

    // レビュアーを追加
    if (description.reviewers.length > 0) {
      await this.octokit.pulls.requestReviewers({
        owner,
        repo: repo.replace('.git', ''),
        pull_number: pr.number,
        reviewers: description.reviewers,
      });
    }

    console.log(`✅ PR #${pr.number} が作成されました: ${pr.html_url}`);
  }

  private async createLocalPR(
    description: PRDescription,
    sourceBranch: string,
    targetBranch: string
  ): Promise<void> {
    // ローカルでPR情報を保存
    const prDir = path.join(this.projectRoot, '.github', 'pull_requests');
    if (!fs.existsSync(prDir)) {
      fs.mkdirSync(prDir, { recursive: true });
    }

    const prData = {
      title: description.title,
      body: description.body,
      source: sourceBranch,
      target: targetBranch,
      labels: description.labels,
      reviewers: description.reviewers,
      created: new Date().toISOString(),
    };

    const prFile = path.join(prDir, `${sourceBranch}-to-${targetBranch}.json`);
    fs.writeFileSync(prFile, JSON.stringify(prData, null, 2));

    console.log(`✅ ローカルPR情報が保存されました: ${prFile}`);
  }

  async reviewPR(prNumber: number): Promise<ReviewComment[]> {
    console.log(`🔍 PR #${prNumber} をレビュー中...`);

    const comments: ReviewComment[] = [];

    // PRの変更を取得
    const changes = await this.getPRChanges(prNumber);

    // 各ファイルをレビュー
    for (const file of changes) {
      const fileComments = await this.reviewFile(file);
      comments.push(...fileComments);
    }

    // 自動レビューコメントを投稿
    if (this.config.autoReview && comments.length > 0) {
      await this.postReviewComments(prNumber, comments);
    }

    return comments;
  }

  private async getPRChanges(prNumber: number): Promise<any[]> {
    // 実際の実装ではGitHub APIまたはローカルgitを使用
    return [];
  }

  private async reviewFile(file: any): Promise<ReviewComment[]> {
    const comments: ReviewComment[] = [];
    const content = file.patch || '';

    // コードスタイルチェック
    if (file.filename.endsWith('.js') || file.filename.endsWith('.ts')) {
      // インデントチェック
      const lines = content.split('\n');
      lines.forEach((line, index) => {
        if (line.startsWith('+') && line.includes('\t')) {
          comments.push({
            path: file.filename,
            line: index + 1,
            message: 'タブの代わりにスペースを使用してください',
            severity: 'warning',
          });
        }
      });

      // console.logチェック
      if (content.includes('console.log')) {
        comments.push({
          path: file.filename,
          line: 1,
          message: 'console.logが残っています。削除してください',
          severity: 'warning',
        });
      }

      // TODOコメントチェック
      if (content.includes('TODO')) {
        comments.push({
          path: file.filename,
          line: 1,
          message: 'TODOコメントがあります。issueを作成することを検討してください',
          severity: 'info',
        });
      }
    }

    // セキュリティチェック
    const securityPatterns = [
      { pattern: /password\s*=\s*["']/, message: 'ハードコードされたパスワードが検出されました' },
      { pattern: /api[_-]?key\s*=\s*["']/, message: 'ハードコードされたAPIキーが検出されました' },
      { pattern: /eval\(/, message: 'eval()の使用は避けてください' },
    ];

    for (const { pattern, message } of securityPatterns) {
      if (pattern.test(content)) {
        comments.push({
          path: file.filename,
          line: 1,
          message,
          severity: 'error',
        });
      }
    }

    return comments;
  }

  private async postReviewComments(prNumber: number, comments: ReviewComment[]): Promise<void> {
    if (!this.octokit) return;

    // コメントをグループ化
    const reviewComments = comments.map((comment) => ({
      path: comment.path,
      line: comment.line,
      body: `${this.getSeverityEmoji(comment.severity)} ${comment.message}`,
    }));

    // レビューを投稿（実際の実装）
    console.log(`📝 ${comments.length}件のレビューコメントを投稿しました`);
  }

  private getSeverityEmoji(severity: ReviewComment['severity']): string {
    const emojis = {
      info: 'ℹ️',
      warning: '⚠️',
      error: '❌',
    };
    return emojis[severity];
  }

  async handleReviewComments(prNumber: number): Promise<void> {
    console.log(`💬 PR #${prNumber} のレビューコメントに対応中...`);

    // レビューコメントを取得
    const comments = await this.getReviewComments(prNumber);

    // 各コメントに対して自動修正を試みる
    for (const comment of comments) {
      await this.handleSingleComment(comment);
    }

    console.log('✅ レビューコメントへの対応が完了しました');
  }

  private async getReviewComments(prNumber: number): Promise<any[]> {
    // 実際の実装ではGitHub APIを使用
    return [];
  }

  private async handleSingleComment(comment: any): Promise<void> {
    // コメントの内容から修正方法を判断
    const message = comment.body.toLowerCase();

    if (message.includes('スペース') || message.includes('indent')) {
      // インデント修正
      await this.fixIndentation(comment.path);
    } else if (message.includes('console.log')) {
      // console.log削除
      await this.removeConsoleLogs(comment.path);
    } else if (message.includes('test')) {
      // テスト追加
      console.log('テストの追加が必要です');
    }
  }

  private async fixIndentation(filePath: string): Promise<void> {
    const fullPath = path.join(this.projectRoot, filePath);
    if (fs.existsSync(fullPath)) {
      const content = fs.readFileSync(fullPath, 'utf-8');
      const fixed = content.replace(/\t/g, '  ');
      fs.writeFileSync(fullPath, fixed);
    }
  }

  private async removeConsoleLogs(filePath: string): Promise<void> {
    const fullPath = path.join(this.projectRoot, filePath);
    if (fs.existsSync(fullPath)) {
      const content = fs.readFileSync(fullPath, 'utf-8');
      const fixed = content.replace(/console\.log\([^)]*\);?\n?/g, '');
      fs.writeFileSync(fullPath, fixed);
    }
  }

  async checkMergeability(prNumber: number): Promise<boolean> {
    console.log(`🔍 PR #${prNumber} のマージ可能性をチェック中...`);

    const checks = {
      conflicts: false,
      testsPass: false,
      approved: false,
      ciPassed: false,
    };

    // コンフリクトチェック
    if (this.config.checkConflicts) {
      checks.conflicts = await this.checkConflicts(prNumber);
    }

    // テスト実行
    if (this.config.runTestsBeforeMerge) {
      checks.testsPass = await this.runTests();
    }

    // 承認チェック
    checks.approved = await this.checkApprovals(prNumber);

    // CI/CDチェック
    checks.ciPassed = await this.checkCIStatus(prNumber);

    const canMerge = !checks.conflicts && checks.testsPass && checks.approved && checks.ciPassed;

    if (canMerge) {
      console.log('✅ PRはマージ可能です');
    } else {
      console.log('❌ PRはまだマージできません:');
      if (checks.conflicts) console.log('  - コンフリクトがあります');
      if (!checks.testsPass) console.log('  - テストが失敗しています');
      if (!checks.approved) console.log('  - 承認が不足しています');
      if (!checks.ciPassed) console.log('  - CI/CDが失敗しています');
    }

    return canMerge;
  }

  private async checkConflicts(prNumber: number): Promise<boolean> {
    // 実際の実装ではGitHub APIまたはgitコマンドを使用
    return false;
  }

  private async runTests(): Promise<boolean> {
    try {
      await execAsync('npm test', { cwd: this.projectRoot });
      return true;
    } catch {
      return false;
    }
  }

  private async checkApprovals(prNumber: number): Promise<boolean> {
    // 実際の実装ではGitHub APIを使用
    return true;
  }

  private async checkCIStatus(prNumber: number): Promise<boolean> {
    // 実際の実装ではGitHub APIを使用
    return true;
  }
}
